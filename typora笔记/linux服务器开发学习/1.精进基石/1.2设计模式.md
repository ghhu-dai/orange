# 1. **创建型设计模式**

**理解 设计模式的切入点**：

1. 该设计模式解决了什么问题：稳定点和变化点
2. 代码结构 
3. 设计原则 
4. 如何 扩展代码
5. 应用场景







## 1.1 模板方法

1. **解决的问题：**
   1. 稳定点：算法骨架
   2. 变化 点：子流程需要变化 
2.  **代码结构 ：**
   1. 基类中有骨架流程接口
   2. 所有子流程对子流程开放并且是虚函数
   3. 多态使用方式，基类指针指向子类对象
3. **符合的设计原则 ：**
   1. 单一职责
   2. 开闭
   3. 依赖倒置：子类的实现依赖基类的虚函数 的实现，使用者只依赖接口
   4. 封闭变化点：`protected`
   5. 接口隔离
   6. 最小知道原则 
4. **如何 扩展：**
   1. 子类继承基类，复写子流程
   2. 通过多态调用方式使用
5. **应用**：很多啊，很多



## 1.2 观察者模式：

1. **解决的问题**：
   1. 稳定点：一对多的依赖关系，“一 ”变化 的时候 “多” 跟着变化 
   2. 变化点：“多”增加/减少
2. **代码结构**：
   1.   
3. **设计原则**:
   1.  面向接口编程
   2. 接口隔离：  类与类依赖一个接口，容器存储接口
   3. 封装变化点：`attach/detach`
4. 如何 扩展
   1. 继承实现接口
   2. 调用attacj
   3. 调用detach





## 1.3 策略模式

1. 解决什么问题：
   1. 稳定点：客户程序 与算法的调用关系
   2. 变化 点：新加算法/算法内容改变 
2. **代码结构** ：   
3. **设计原则** ：
   1. 接口隔离：依赖注入（通过一个接口解决两个类的依赖）
   2. 面向接口编程： 
   3. 开闭原则
4. **如何扩展代码**





## 1.4 单例模式

定义：保证一个类仅有一个实例，并提供一个该实例的全局访问点

1. **解决了什么问题**：
   1. 稳定点：类只有一个实例，提供全局的访问点
   2. 变化 点：有多个类都是单例，能不能利用代码 （继承/组合）
2. **代码结构**
   1. 私有的构造和析构
   2. 禁掉拷贝构造，拷贝赋值，移动构造，移动赋值
   3. 静态类成员函数 
   4. 静态私有成员变量